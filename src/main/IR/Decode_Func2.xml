<Module type="Decode_Func">
	<Parameters>
	</Parameters>
	<Interface>
	    <!-- Interfaces for each Functional Unit -->
	    <Input name="Insn" type="[31:0]" description="Instructions that need to be decoded"/>
	    <!-- Outputs from each Functional Unit  -->
	    <Output name="IsaRs1" type="[4:0]" description="Address of the rs1 register"/>
	    <Output name="Operand1Ready" type="" description="Whether the rs1 operand is ready"/>
	    <Output name="IsaRs2" type="[4:0]" description="Address of the rs2 register"/>
	    <Output name="Operand2Ready" type="" description="Whether the rs2 operand is ready"/>
	    <Output name="IsaRd" type="[4:0]" description="Address of the rd register"/>
	    <Output name="ControlFlowInsn" type="" description="Whether is Control-flow instruction, indicating whether the instruction changes the flow of program execution"/>
	    <Output name="Function_type" type="[2:0]" description="The execution unit that the instruction needs to call, including ALU, BRU, CSR, LDU, STU"/>
	    <Output name="Sub_OP" type="[3:0]" description="The specific action that the instruction needs to perform in the execution unit"/>
	    <Output name="imm" type="[31:0]" description="Store immediate numbers"/>
	    <Output name="excp_vaild" type="" description="Stores exceptions for the current instruction"/>
	    <Output name="excp_cause" type="[5:0]" description="Stores the type of the current exception instruction"/>
	    <Output name="excpt_tval" type="[31:0]" description="The address of the current exception instruction is stored"/>
	</Interface>
    <Function description="This module is a decoding module for the riscv processor that supports riscv64i and m mode. It can parse instructions into internal control signals and operands, and needs to be able to handle the following instructions: 4. Load instructions (0b0000011): LB/LH/LW/LD/LBU/LHU/LWU: Process various load instructions, set the functional unit to LDU (loadunit), and set the sub-operation type according to the specific load type (byte, half word, word, double word and its unsigned variants). 5. Storage instructions (0b0100011): SB/SH/SW/SD: Process various storage instructions, set the functional unit to STU (storage unit),and set the sub-operation type according to the data type stored (byte, half word, word, double word). 6. Branch instructions (0b1100011): BEQ/BNE/BLT/BGE/BLTU/BGEU: These instructions handle various branch instructions, set the functional unit as BRU (branch unit), andset the sub-operation type according to the specific branch type. These instructions set the control flow flag, which affects the jumpof the program counter (PC). 7. JAL/JALR (0b1101111 and 0b1100111): JAL/JALR: These instructions handle jump and link instructions as well as register jumpinstructions, set as ALU or BRU functional unit, marked as control flow instruction, and provide immediate number or register value forjump calculation."/>
<ReferenceModel code="void Decode_Func(Emulator::DynInsn&amp; insn){ StaticInsn instr(insn.UncompressedInsn); insn.IsaRs1  = instr.rs1();//insn[19:15] insn.IsaRs2  = instr.rs2();//insn[24:20] insn.IsaRd   = instr.rd();//insn[11:7] insn.Operand1Ready = false; insn.Operand2Ready = false; insn.ControlFlowInsn = false; insn.imm     = 0; insn.Fu          = Emulator::funcType_t::ALU; insn.SubOp       = ALU_ADD; bool    illegal_instr = false; bool    ecall   = false; bool    ebreak  = false; switch (instr.opcode())////insn[6:0] { case 0b0000011: insn.Fu = Emulator::funcType_t::LDU; insn.imm = instr.iimm(); switch (instr.func3()) { case 0b000:insn.SubOp = LDU_LB;break; case 0b001:insn.SubOp = LDU_LH;break; case 0b010:insn.SubOp = LDU_LW;break; case 0b011:insn.SubOp = LDU_LD;break; case 0b100:insn.SubOp = LDU_LBU;break; case 0b101:insn.SubOp = LDU_LHU;break; case 0b110:insn.SubOp = LDU_LWU;break; default:illegal_instr = true;break; } break; case 0b0100011: insn.Fu = Emulator::funcType_t::STU; insn.imm = instr.simm(); insn.IsaRd=0; switch (instr.func3()) { case 0b000:insn.SubOp = STU_SB;break; case 0b001:insn.SubOp = STU_SH;break; case 0b010:insn.SubOp = STU_SW;break; case 0b011:insn.SubOp = STU_SD;break; default:illegal_instr = true;break; } break; case 0b1100011: insn.Fu  = Emulator::funcType_t::BRU; insn.imm = instr.sbimm(); insn.ControlFlowInsn = true; insn.IsaRd=0; switch (instr.func3()) { case 0b000:insn.SubOp = BRU_BEQ;break; case 0b001:insn.SubOp = BRU_BNE;break; case 0b100:insn.SubOp = BRU_BLT;break; case 0b101:insn.SubOp = BRU_BGE;break; case 0b110:insn.SubOp = BRU_BLTU;break; case 0b111:insn.SubOp = BRU_BGEU;break; default:illegal_instr = true;break; } break; case 0b1101111: insn.Fu = Emulator::funcType_t::ALU; insn.SubOp = ALU_ADD; insn.Operand1 = insn.Pc; insn.Operand2 = 4; insn.Operand1Ready = true; insn.Operand2Ready = true;break; case 0b1100111: insn.Fu  = Emulator::funcType_t::BRU; insn.SubOp = BRU_JALR; if(instr.func3() != 0)illegal_instr = true; insn.imm = instr.iimm(); insn.ControlFlowInsn = true; break; default:illegal_instr = true;break; } if(ecall){ insn.Excp.valid = true; insn.Excp.Tval  = 0; insn.Excp.Cause =11; }else if(ebreak){ insn.Excp.valid = true; insn.Excp.Cause = 3; insn.Excp.Tval  = 0; } if(illegal_instr){ insn.Excp.valid = true; insn.Excp.Cause = 2; insn.Excp.Tval  = insn.UncompressedInsn; } else{ insn.Excp.valid    = 0; insn.Excp.Cause    = 0; insn.Excp.Tval     = 0; }}" />    
</Module>
<!-- Definitions for Request and Result types for each Functional Unit -->
