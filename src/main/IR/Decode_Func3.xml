<Module type="Decode_Func">
	<Parameters>
	</Parameters>
	<Interface>
	        <Input name="Insn" type="[31:0]" description="Instructions that need to be decoded"/>
	        <Output name="IsaRs1" type="[4:0]" description="Address of the rs1 register"/>
	        <Output name="Operand1Ready" type="" description="Whether the rs1 operand is ready"/>
	        <Output name="IsaRs2" type="[4:0]" description="Address of the rs2 register"/>
	        <Output name="Operand2Ready" type="" description="Whether the rs2 operand is ready"/>
	        <Output name="IsaRd" type="[4:0]" description="Address of the rd register"/>
	        <Output name="ControlFlowInsn" type="" description="Whether is Control-flow instruction, indicating whether the instruction changes the flow of program execution"/>
	        <Output name="Function_type" type="[2:0]" description="The execution unit that the instruction needs to call, including ALU, BRU, CSR, LDU, STU"/>
	        <Output name="Sub_OP" type="[3:0]" description="The specific action that the instruction needs to perform in the execution unit"/>
	        <Output name="imm" type="[31:0]" description="Store immediate numbers"/>
	        <Output name="excp_vaild" type="" description="Stores exceptions for the current instruction"/>
	        <Output name="excp_cause" type="[5:0]" description="Stores the type of the current exception instruction"/>
	        <Output name="excpt_tval" type="[31:0]" description="The address of the current exception instruction is stored"/>
	</Interface>
    <Function description="This module is a decoding module for the riscv processor that supports riscv64i and m mode. It can parse instructions into internal control signals and operands, and needs to be able to handle the following instructions: 8. ALU operation instructions (0b0110011): ADD/SUB/SLT/SLTU/XOR/OR/AND/SLL/SRL/SRA: These instructions handle basic arithmetic logicunit operation instructions, set the functional unit as ALU, and set the sub-operation according to the operation type. This includesaddition, subtraction, logic and arithmetic right shift, etc. 9. IMM operation instructions (0b0010011): These instructions handle immediate number version of arithmetic logic instructions, such asADDI, SLTI, etc., set the functional unit as ALU and provide immediate number as operand. 10. 32-bit operation instructions (0b0111011 and 0b0011011): These instructions handle 32-bit data width operation instructions, such asADDW, SUBW, etc., set the ALU functional unit for them and handle the corresponding operation. 11. AUIPC/LUI (0b0010111 and 0b0110111): These instructions handle address calculation and load upper bound instructions, which use ALU functional unit and directly use immediate number as operand, and add to the program counter or zero."/>
<ReferenceModel code="void Decode_Func(Emulator::DynInsn&amp; insn){ StaticInsn instr(insn.UncompressedInsn); insn.IsaRs1 = instr.rs1();//insn[19:15] insn.IsaRs2 = instr.rs2();//insn[24:20] insn.IsaRd = instr.rd();//insn[11:7] insn.Operand1Ready = false; insn.Operand2Ready = false; insn.ControlFlowInsn = false; insn.imm = 0; insn.Fu = Emulator::funcType_t::ALU; insn.SubOp = ALU_ADD; bool illegal_instr = false; bool ecall = false; bool ebreak = false; switch (instr.opcode())////insn[6:0] { case 0b0110011: switch (instr.func7()) { case 0b0000000: insn.Fu = Emulator::funcType_t::ALU; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_ADD;break; case 0b001:insn.SubOp = ALU_SLL;break; case 0b010:insn.SubOp = ALU_SLT;break; case 0b011:insn.SubOp = ALU_SLTU;break; case 0b100:insn.SubOp = ALU_XOR;break; case 0b101:insn.SubOp = ALU_SRL;break; case 0b110:insn.SubOp = ALU_OR;break; case 0b111:insn.SubOp = ALU_AND;break; default:illegal_instr = true;break; } break; case 0b0100000: insn.Fu = Emulator::funcType_t::ALU; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_SUB;break; case 0b101:insn.SubOp = ALU_SRA;break; default:illegal_instr = true;break; } break; default:illegal_instr = true;break; } break; case 0b0111011: switch (instr.func7()) { case 0b0000000: insn.Fu = Emulator::funcType_t::ALU; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_ADDW;break; case 0b001:insn.SubOp = ALU_SLLW;break; case 0b101:insn.SubOp = ALU_SRLW;break; default:illegal_instr = true;break; } break; case 0b0100000: insn.Fu = Emulator::funcType_t::ALU; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_SUBW;break; case 0b101:insn.SubOp = ALU_SRAW;break; default:illegal_instr = true;break; } break; default:illegal_instr = true;break; } break; case 0b0010011: insn.Fu = Emulator::funcType_t::ALU; insn.imm = instr.iimm(); insn.Operand2 = instr.iimm(); insn.Operand2Ready = true; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_ADD;break; case 0b001: insn.Operand2 = instr.shamt(); insn.SubOp = ALU_SLL; if((instr.func7() &gt;&gt; 1) != 0){ illegal_instr = true; } break; case 0b010:insn.SubOp = ALU_SLT;break; case 0b011:insn.SubOp = ALU_SLTU;break; case 0b100:insn.SubOp = ALU_XOR;break; case 0b101: insn.Operand2 = instr.shamt(); if((instr.func7() &gt;&gt; 1) == 0b000000){ insn.SubOp = ALU_SRL; }else if((instr.func7() &gt;&gt; 1) == 0b010000){ insn.SubOp = ALU_SRA; }else{ illegal_instr = true; } break; case 0b110:insn.SubOp = ALU_OR;break; case 0b111:insn.SubOp = ALU_AND;break; default:illegal_instr = true;break; } break; case 0b0011011: insn.Fu = Emulator::funcType_t::ALU; insn.imm = instr.iimm(); insn.Operand2 = instr.iimm(); insn.Operand2Ready = true; switch (instr.func3()) { case 0b000:insn.SubOp = ALU_ADDW;break; case 0b001: insn.Operand2 = instr.shamt(); insn.SubOp = ALU_SLLW; if(instr.func7() != 0){ illegal_instr = true; } break; case 0b101: insn.Operand2 = instr.shamt(); if(instr.func7() == 0b0000000){ insn.SubOp = ALU_SRLW; }else if(instr.func7() == 0b0100000){ insn.SubOp = ALU_SRAW; }else{ illegal_instr = true; } break; default:illegal_instr = true;break; } break; case 0b0010111: insn.Fu = Emulator::funcType_t::ALU; insn.SubOp = ALU_ADD; insn.Operand1 = instr.uimm(); insn.Operand2 = insn.Pc; insn.Operand1Ready = true; insn.Operand2Ready = true; insn.imm = instr.uimm(); break; case 0b0110111: insn.Fu = Emulator::funcType_t::ALU; insn.SubOp = ALU_ADD; insn.Operand1 = instr.uimm(); insn.Operand2 = 0; insn.Operand1Ready = true; insn.Operand2Ready = true; insn.imm = instr.uimm(); break; default:illegal_instr = true;break; } if(ecall){ insn.Excp.valid = true; insn.Excp.Tval = 0; insn.Excp.Cause =11; }else if(ebreak){ insn.Excp.valid = true; insn.Excp.Cause = 3; insn.Excp.Tval = 0; } if(illegal_instr){ insn.Excp.valid = true; insn.Excp.Cause = 2; insn.Excp.Tval = insn.UncompressedInsn; } else{ insn.Excp.valid = 0; insn.Excp.Cause = 0; insn.Excp.Tval = 0; } }"/>    
</Module>
