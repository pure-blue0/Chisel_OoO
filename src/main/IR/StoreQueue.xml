<Module type="StoreQueue">
    <Function description="This module is used to store instruction requests sent to memory and is a circular queue with a depth of Store_queue_size and a width of 138. Since this is a circular queue, when the header, tail, or nextTail reaches the end of the queue beyond the boundary of the queue, it will automatically point to the end of the queue, thus implementing a loop. In addition, the queue can update the data in the entry according to the input signal at each rising edge of the clock, and it can also use the combinational logic to output the relevant data at any time by query. The format of the data stored in an entry is as follows: |137:134|Sub_OP |133:130|LSQTag |129:126|RobTag |125:120|PhyRs1 |119:114|PhyRs2 |113:108|PhyRd |107:102|LPhyRd |101:100|state |99|commited |98|Killed |97|addressReady |96:65|address |64|dataReady |63:0|data|. When reset=0, the data stored in the entry in the queue are initialized to 0, the line head pointer, the line tail pointer, the number of entries used usage, Empty are initialized to 0, and nextTail is set to 1 to represent the next tail pointer. On the rising edge of the clock, data will be written to the queue in order according to the input LA_EN1 and LA_EN2. First, it is checked whether LA_EN1 is 1; if so, Entry_data1 is written to entry pointed to by tail, and both tail and nextTail are incremented by 1; Then it checks whether LA_EN2 is 1; if so, it writes Entry_data2 to entry pointed to by tail, and sets both tail and nextTail to increment by 1. On the rising edge of the clock, if Store_Write_valid=1, it means that the LSQ_WriteBack module requests to update the data of the Store Queue, then according to the input WB_LSQTag, and the input data WB_addressReady, WB_address, WB_data updates the addressReady and address, data in the corresponding entry, leaving the rest unchanged. On the rising edge of the clock, if TryIssue_valid=1, it means that the TryIssueStore module requests to update the Store Queue data, then according to the input TryIssue_stqPtr, And the input data TryIssue_state updates the state in the corresponding entry, leaving the rest unchanged. On the rising edge of the clock, the Killed of the corresponding entry will be set to 1 according to the RR_valid1 and RR_valid2 input and the value of LSQtag, indicating that the entry is invalid. First, it checks whether RR_valid1 is 1; if so, it sets the Killed value of entry pointed to by LSQtag1 to 1; Then it checks whether RR_valid2 is 1; if so, it sets the Killed value of entry pointed to by LSQtag2 to 1. On the rising edge of the clock, the instruction will be submitted according to the input Commit_vaild1 and Commit_vaild2.First, check whether Commit_vaild1 is 1. If it is, set commited in entry Commit_LSQTag1 to 1, indicating that this entry can be committed.Then check whether Commit_vaild2 is 1. If yes, set the commited value in the entry Commit_LSQTag2 to 1, indicating that this entry can be committed. On the rising edge of the clock, if the queue is not empty, the queue determines whether to pop the entry off the queue based on the Killed, state data stored in the entry pointed to by the current header pointer. If killed is 1 and state is not equal to 1, indicating that the entry is invalid, then header+1 indicates the commit instruction and usage-1 will be used. On the rising edge of the clock, if the queue is not empty, if pop_header=1, the entry pointed to by the current header pointer will be ejected from the queue, that is, header+1 indicates a commit instruction and will use -1. On the rising edge of the clock, if D_state_valid=1, the state in the entry pointed by D_LSQTag will be updated to 2; Output AvailEntryCount=store_queue_size-usage, the current queue tail pointer and the next queue tail pointer nextTail, the value of Empty (Empty=1 when usage=0), and the line header, FrontQueue_addressReady, FrontQueue_commited, FrontQueue_state, FrontQueue_address, FrontQueue_data, FrontQueue_subop"/>
    <Parameters>
        <Parameter name="store_queue_size" type="integer" value="8" description="Specifies the depth of the Store Queue which is the number of entries it can hold."/> 
    </Parameters>
    <Interface>
        <Input name="Clk" type="signal" description="A clock signal that coordinates the timing of the module's operations."/>
        <Input name="reset" type="signal" description="Reset signal, used to initialize or reset the state of the queue, pointers, and counters to their default values."/>
        <Input name="Entry_data1" type="[137:0]" description="The first input data port, used to write data for the first instruction into the queue."/>
        <Input name="Entry_data2" type="[137:0]" description="The second input data port, used to write the data of the second instruction into the queue."/>
        <Input name="LA_EN1" type="signal" description="The first write enable signal that determines if Entry_data1 should be written to the queue."/>
        <Input name="LA_EN2" type="signal" description="The second write enable signal that determines if Entry_data2 should be written to the queue."/>
        <Input name="Store_Write_valid" type="signal" description="A validation signal indicating that the LSQ_WriteBack module is requesting to write to the Store Queue."/>
        <Input name="WB_addressReady" type="signal" description="A flag indicating whether the memory address for the instruction is ready."/>
        <Input name="WB_address" type="[31:0]" description="The memory address that the instruction will access."/>
        <Input name="WB_data" type="[31:0]" description="The data that the instruction will write to memory."/>
        <Input name="WB_LSQTag" type="[3:0]" description="The tag that identifies the entry in the Store Queue that the LSQ_WriteBack module intends to update."/>
        <Input name="TryIssue_valid" type="signal" description="A validation signal indicating that the TryIssueStore module is requesting to update the data in the Store Queue."/>
        <Input name="TryIssue_state" type="[1:0]" description="The new state to be updated in the specified entry by the TryIssueStore module."/>
        <Input name="TryIssue_stqPtr" type="[3:0]" description="The pointer that identifies which entry the TryIssueStore module intends to update."/>
        <Input name="RR_valid1" type="signal" description="A signal from the ReleaseResource module requesting to mark an entry as invalid based on LSQtag1."/>
        <Input name="LSQtag1" type="[5:0]" description="The tag used by the ReleaseResource module to identify the first entry to be marked as invalid."/>
        <Input name="RR_valid2" type="signal" description="A signal from the ReleaseResource module requesting to mark an entry as invalid based on LSQtag2."/>
        <Input name="LSQtag2" type="[5:0]" description="The tag used by the ReleaseResource module to identify the second entry to be marked as invalid."/>
        <Input name="Commit_vaild1" type="signal" description="A signal indicating that the entry identified by Commit_LSQTag1 is to be committed."/>
        <Input name="Commit_LSQTag1" type="[3:0]" description="The tag identifying the first entry to be committed."/>
        <Input name="Commit_vaild2" type="signal" description="A signal indicating that the entry identified by Commit_LSQTag2 is to be committed."/>
        <Input name="Commit_LSQTag2" type="[3:0]" description="The tag identifying the second entry to be committed."/>
        <Input name="D_state_valid" type="signal" description="A signal from the dcache ReceiveRespone module indicating a request to update the state of an entry."/>
        <Input name="D_LSQTag" type="[3:0]" description="The tag used by the dcache ReceiveRespone module to identify which entry's state is to be updated."/>
        <Output name="AvailEntryCount" type="[3:0]" description="The number of free entries available in the Load Queue."/>
        <Output name="Empty" type="signal" description="A flag that indicates whether the queue is empty (1 if empty, 0 otherwise)."/>
        <Output name="header" type="[3:0]" description="The position of the current front entry in the load queue."/>
        <Output name="FrontQueue_commited" type="signal" description="Indicates whether the current front entry can be committed (1 if committable, 0 otherwise)."/>
        <Output name="FrontQueue_state" type="[1:0]" description="The state of the current front entry in the load queue."/>
        <Output name="FrontQueue_address" type="[31:0]" description="The memory address where the current front entry needs to store data."/>
        <Output name="FrontQueue_data" type="[63:0]" description="The data that the current front entry will write to memory."/>
        <Output name="FrontQueue_subop" type="[3:0]" description="The specific sub-operation that the current front entry will perform."/>
    </Interface>
    <!-- Instances would be added here if any were specified -->
    <ReferenceModel code="The reference model written in C++, containing the functions of the module, is not provided here. To include the reference model, embed the actual C++ code within the code attribute."/>    
</Module>
<!-- Definitions for Request and Result types for each Functional Unit -->
